# -*- coding: utf-8 -*-
"""Data Classification with Booking Cancellations.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12JkJ4zFS34FgPdWxA7mRO4rhSGwy-kgL
"""

import numpy as np
import pandas as pd

data = pd.read_csv("CourseData.csv")

data.head()

data.shape

print("Row count of our data is {}".format(data.shape[0]))

data.columns

data.iloc[data["no_of_previous_cancellations"].idxmax()]

data.iloc[data["no_of_previous_cancellations"].idxmin()]

data.iloc[data["avg_price_per_room"].idxmax()]

data.iloc[data["avg_price_per_room"].idxmin()]

data.isnull().sum()

data.duplicated().sum()

data.columns

import matplotlib.pyplot as plt
import seaborn as sns

data["no_of_children"].value_counts().sort_values(ascending=False)

sns.countplot(x="no_of_children", data=data)

data["type_of_meal_plan"].value_counts().sort_values(ascending=False)

mealtypelabels = data["type_of_meal_plan"].unique()

plt.pie(data["type_of_meal_plan"].value_counts(), labels=mealtypelabels)
plt.show()

data["room_type_reserved"].value_counts().sort_values(ascending=False)

sns.countplot(y="room_type_reserved", data=data)

data["required_car_parking_space"].value_counts().sort_values(ascending=False)

sns.countplot(x="required_car_parking_space", data=data)

data["booking_status"].value_counts().sort_values(ascending=False)

bookinglabels = data["booking_status"].unique()
plt.pie(data["booking_status"].value_counts(), labels=bookinglabels)
plt.show()

data.columns

data = data[["no_of_adults","no_of_children","no_of_weekend_nights","no_of_week_nights","type_of_meal_plan","room_type_reserved","no_of_previous_cancellations","avg_price_per_room","booking_status"]]

data.head()

from sklearn.preprocessing import LabelEncoder
labelencoder = LabelEncoder()

data["type_of_meal_plan"].head()

data["type_of_meal_plan"] = labelencoder.fit_transform(data["type_of_meal_plan"])

data["type_of_meal_plan"].head()

data["room_type_reserved"] = labelencoder.fit_transform(data["room_type_reserved"])
data["booking_status"] = labelencoder.fit_transform(data["booking_status"])

data.head()

data.corr()["booking_status"].sort_values(ascending=True)

sns.heatmap(data=data.corr(), annot=True)

data.columns

X = data[["no_of_adults","no_of_children","no_of_weekend_nights","no_of_week_nights","type_of_meal_plan","room_type_reserved","no_of_previous_cancellations","avg_price_per_room"]]
y = data[["booking_status"]]

from sklearn.model_selection import train_test_split
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)

from sklearn.preprocessing import StandardScaler
scaler = StandardScaler()
scaled_X_train = scaler.fit_transform(X_train)
scaled_X_test = scaler.fit_transform(X_test)

from sklearn.metrics import accuracy_score
def modelresults(predictions):
  print(f"Accuracy score of the model is {accuracy_score(y_test, predictions)}")

from sklearn.linear_model import LogisticRegression
log_model = LogisticRegression()
log_model.fit(scaled_X_train, y_train)

log_predictions = log_model.predict(scaled_X_test)
modelresults(log_predictions)

from sklearn.neighbors import KNeighborsClassifier
from sklearn.model_selection import GridSearchCV
from sklearn.pipeline import Pipeline
knn = KNeighborsClassifier()
k_values = list(range(1, 30))
pipe = Pipeline(steps=[("knn", knn)])
param_grid = {"knn__n_neighbors": k_values}
cv_classifier = GridSearchCV(pipe, param_grid, cv=5, scoring="accuracy")
cv_classifier.fit(scaled_X_train, y_train)
print(cv_classifier.best_params_)

pred_gridknn = cv_classifier.predict(scaled_X_test)
modelresults(pred_gridknn)

from sklearn.ensemble import RandomForestClassifier
rfr_model = RandomForestClassifier()
n_estimators = [32, 64, 128]
max_features = [2, 3]
bootstrap = [True, False]
oob_score = [True, False]
param_grid_rfr = {"n_estimators": n_estimators, "max_features": max_features, "bootstrap": bootstrap, "oob_score": oob_score}
grid_rfr = GridSearchCV(rfr_model, param_grid_rfr)
grid_rfr.fit(scaled_X_train, y_train)
print(grid_rfr.best_params_)

predsrfc = grid_rfr.predict(scaled_X_test)
modelresults(predsrfc)

print(X.describe())

customerdata = np.array([2, 1, 1, 2, 1, 1, 0, 110])

def cancelornot(customer):
  predictions = (cv_classifier.predict(customer.reshape(1, -1)))
  if predictions == 1:
    return "won't cancel the booking"
  else:
    return "will cancel the booking"

print("This customer {} according to the K Nearest Neighbors model".format(cancelornot(customerdata)))